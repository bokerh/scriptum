## Composing Monadic Effects with Transformers

Monadic effect composition is one of the more difficult topics of the functional paradigm and quite frankly, it is a bit hackish and still too ad-hoc. It needs a lot of experience to apply the technique properly. Prepare to get your hands dirty in this chapter.

### Monads do not compose in general

As opposed to functors and applicatives monads of different type do not compose, that is, there is no general, mechanical way to combine any two monads so that the result is always a new, lawful monad. We cannot just write,

```
// mmx has type M<N<A>> where M and N are monads of different type

chain1(mmx) (mx => // M structure
  chain2(mx) (x => // N structure
    ...));
```
because some compositions will not work at all, whereas others will break the monad laws and behave unexpectedly.

The problem arises from the fact that monads allow interference between effects and values. The application of `A => M<N<B>>` with `M<N<A>>`, where `M<N<B>>` may depend on a value of type `A`, leads to the intermediate result `M<N<M<N<B>>>>`:

```javascript
// unoin constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

// ARRAY

// functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// MAIN

const foo = s => [ Some(s.toUpperCase())]; // monadic action
//          A => M<N   <B              >>

const ttx = [ Some("foo")];
//          M<N   <A    >>

arrMap(optMap(foo)) (ttx); // [ Some<[ Some<string>]>]
//                            M<N   <M<N   <B     >>>>
```
[run code](https://repl.it/@scriptum/NavyNovelScale)

It is an intermediate result, because we need to get rid of the additional nested monadic structure. Joining two layers of structure is what distinguishes a monad from a mere functor. On the one hand we cannot just join the `M` and `N` structures, because they are of different type. On the other hand we cannot just swap the inner types to get `M<M<N<N<B>>>>` either, because this would require all monads to be commutative. So we are stuck with `M<N<M<N<B>>>>`. In order to join the structures anyway we need to know at least the type of `N`.

### Higher order monads to the rescue

If we know the type of `N` we can incorporate the corresponding joining logic into the monad. All that is misisng now is the outer monad `M`. Since it should be any monad we need to pass it as an argument, i.e. we have created an higher order monad, better known as monad transformer.

#### Monad/monad transformer relation

Even though monad transformers often share their name of their underlying single monad there is no one-to-one relationship between them. A data type with a single monad instance might have one, several or no meaningful transformer instance at all.

#### Monad transformer under the hood

A monad transformer `T` for the underlying monadic type `M` reifies at the term level by a specific implementation of the monad operations `chain`/`of`:

```javascript
const ofT = ofN => x => ...
const chainT = chainN => mmx => fmm => ...
```
The most obvious difference to those operations of a single monad is the additional, first formal parameter in the function signatures, which represents the monad `N` passed as an argument. It is tempting to incorporate `M`'s `chain` and `of` operations into `T`s implementation. But as I have already mentioned their is no one-to-one relationship between both. A transformer and its underlying monad may resemble each other in part of their effects, but ultimately they are completely different types. You have to build each transformer operations from scratch. Moreover, `T` must not know anything about its argument `N` except that it is also a monad.

### Effect interleaving

Technically speaking the known monad of the transformer stack is the inner one, whereas the monad provided as an argument is the outer monad of the composition:

```javascript
const ofT = ofN => x => ... // creates a value of type M<N<A>>
//   <M    <N     <A>>>
```
At the effect layer, however, there is no static inner-outer effect nesting. Depending on the monad transformer type effects are interleaved in various ways. As a rule of thumb you can expect the innder monad to provide the predominant effect.

It is also important to understand that monad transformer are not commutative, i.e. `M<N<A>>` is not the same as and not even similar to `N<M<A>>`. With monad transformers ordering matters.

### Monad transformer stacks

***

The monad transformer mechanism is composable, i.e. you can take a partially applied monad transformer and apply it to another one. In functional programming jargon this forms a monad transformer stack. Just like for a single monad transformer the innermost monad determines the dominant effect of the stack.

Please note that the transformer stack we are going to build in the following sections is rather contrived. I want you to solely focus on the mechanics of the effect composition rather than on the question if a particularly transformer stack is useful in practice.

#### `EitherT`/`Array`


#### Illegal `ArrayT`/`Either`

* proof lawlessness with non-commutative base monad
* how to determine if a monad is non-commutative

#### Legal ~~`ArrayT`~~`ListT`/`Either`

* proof lawfulness with non-commutative base monad

#### `OptionT`/`Task`


#### `OptionT`/`TaskT`/`Array`


#### `OptionT`/`TaskT`/`ArrayT`/`Trampoline`

* `ArrayT` is still useful along with commutative base-monads

#### `WriterT`/`Trampoline`


#### `TaskT`/`Trampoline`

* demonstrate stack-safety of post-recursion with the `Trampoline` monad
* not sure yet if it actually works

### Generalized lifting

* polymorphic `lift` function

### Transformers in the wild

* Kleisli arrows are monad transformers where an arbitrary outer monad is composed with the function monad

### Alternative approaches

#### Pre-composed monads

* you can write your own hard-coded monad composition

#### Continuation monad encodings

* every monad transformer can be encoded with the continuation monad

***

#### `OptionT`/`Array`

Here comes our first monad transformer stack `[Option<A>]`. `OptionT` is the transformer and `Array` the base monad:

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// Transformer

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

const optOfT = of => x => of(Some(x));

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// transformer stack

const optArrChain = optChainT(
  {chain: arrChain, of: arrOf});

const optArrOf = optOfT(arrOf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

const arrCons = x => xs =>
  [x].concat(xs);

// MAIN

const mmx = [Some(10), Some(20), Some(30)],
  mmy = [Some(0), Some(2), Some(3)];
  
const main =
  optArrChain(mmx) (x =>
    optArrChain(mmy) (y =>
      y === 0 ? [None] // A
        : x % y !== 0 ? [] // B
        : optArrOf(x / y)));

main; // [None, Some(5), None, Some(10), None, Some(15), Some(10)]
```
[run code](https://repl.it/@scriptum/PaleStrictTraining)

The example above exhibits two interleaved effects. The first one consists in `None` values that encode the division-by-zero error (line `A`). The second one consists in a non-deterministic length of the array due to filtered quotients including a fraction (line `B`). 

Please note that usually each monad transformer has its own type wrapper. However, in an untyped environment like Javascript I refrain from doing so. Without a static type system the increased type safety is disproportionate to the continuous wrapping and unwrapping.

#### Illegal `ArrayT`/`Option`

Monat transformers are not commutative, i.e. the interaction of two effects can be controlled by picking a specific stack order. On the one hand the `OptionT`/`Array` stack constitutes an non-deterministic array of independent, optional values, that is, if a single computation inside the array does not yield a result, only this very element becomes `None`. On the other hand the `ArrayT`/`Option` stack constitutes an optional non-deterministic array, that is, if a single computation inside the array does not yield a result, the entire array is dropped and replaced by `None`:

```javascript
// ARRAY

// Transformer

const arrChainT = ({map, ap, of ,chain}) => mmx => fmm =>
  chain(mmx) (mx => {
    const go = ([x, ...xs]) =>
      x === undefined
        ? of([])
        : ap(map(arrCons) (fmm(x))) (go(xs));

    return chain(go(mx)) (ys => of(arrFold(arrAppend) ([]) (ys)));
  });

const arrOfT = of => x => of([x]);

// OPTION

// Functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

// Applicative

const optAp = tf => tx =>
  match(tf, {
    None: _ => None,
    Some: ({some: f}) => {
      return match(tx, {
        None: _ => None,
        Some: ({some: x}) => Some(f(x))
      });
    }
  });

const optOf = x => Some(x);

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

// transformer stack

const arrOptChain = arrChainT(
  {map: optMap, ap: optAp, of: optOf, chain: optChain});

const arrOptOf = arrOfT(optOf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

const arrCons = x => xs =>
  [x].concat(xs);

// MAIN

const mmx = Some([10, 20, 30]),
  mmy = Some([1, 2, 3]),
  mmz = Some([0, 2, 3]);

const main =
  arrOptChain(mmx) (x => {
    return arrOptChain(mmy) (y => {
      return y === 0 ? None
        : x % y !== 0 ? Some([])
        : arrOptOf(x / y)})});

const main2 =
  arrOptChain(mmx) (x => {
    return arrOptChain(mmz) (z => {
      return z === 0 ? None
        : x % z !== 0 ? Some([])
        : arrOptOf(x / z)})});

main; // Some([10, 5, 20, 10, 30, 15, 10])
main2; // None
```
[run code](https://repl.it/@scriptum/DiligentOtherDebugmonitor)

Both examples clearly illustrate the differences. However, `ArrayT`/`Option` is not even a valid monad, because it requires the base monad to be commutative, which `Option` happens to be. Let us look at another example where I use another array as the base monad for the sake of simplicity:

```javascript
// MAIN

const foo = x =>
  x === 0
    ? [[0, 1]]
    : [[0], [1]];

console.log(
  arrArrChain(arrArrChain(foo(0)) (foo)) (foo));
    // yields [[0,1,0,0,1],[0,1,1,0,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,1,1]]


console.log(
  arrArrChain(foo(0)) (x => arrArrChain(foo(x)) (foo)));
    // yields [[0,1,0,0,1],[0,1,0,0],[0,1,0,1],[0,1,1,0,1],[0,1,1,0],[0,1,1,1]]
```
[run code](https://repl.it/@scriptum/NutritiousRowdyWearables)

Array is not commutative monad hence the results differ and the monad associative law is broken. You may wonder why I do not present the right implementation - because I do not know it. I am not sure if with an strictly evaluated array it is possible at all to come up with a lawful solution. Implementing new, lawful monad transformer is hard and you should give yourself some time to gain experience.

#### Lawful `ListT`/`Option`

TODO

#### `TaskT`/`OptionT`/`Array`

TODO

#### `ArrayT`/`Either`

Warning: I will cheat in this section. Insteafd of the lawful linked list based transformer stack I am going to use the invalid `ArrayT` implementation, because it is close enough for the purpose of iluustration in the context of this course. `ListT` is just too complex and would contradict this very purpose.

```javascript
```
[run code]()

* add short circuit semantics to the transformer stack

#### `OptionT`/`Trampoline`

```javascript
```
[run code](https://repl.it/@scriptum/FrizzyWornFormulas)

* add stack-safety to the transformer stack
* `Trampoline` does not have a transformer

***

* [run code](https://repl.it/@scriptum/FelineLoyalCache) `OptionT`/`Eff`
* [run code](https://repl.it/@scriptum/ClumsyDullApplicationframework) `OptionT`/`EffT`/`Array`
* [run code](https://repl.it/@scriptum/WarpedBeigeNumerators) `OptionT`/`Array`
* [run code](https://repl.it/@scriptum/JumboTrickyActivecontent) `ArrayT`/`Option`
* [run code](https://repl.it/@scriptum/OrganicWheatMisrac) `ArrayT`/`Option` (stack overflow)
* [run code](https://repl.it/@scriptum/NutritiousRowdyWearables) `ArrayT`/`Option` (invalid)
* [run code](https://repl.it/@scriptum/MoralAuthorizedComputergames) `ListT`/`Option` (done right)
* [run code](https://repl.it/@scriptum/DefiniteLastFiles) `EitherT`
